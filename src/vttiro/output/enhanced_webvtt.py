# this_file: src/vttiro/output/enhanced_webvtt.py
"""Simple WebVTT formatter focused on core functionality.

This module provides basic WebVTT generation without over-engineered
accessibility compliance, quality metrics, or complex formatting.

Focus: Generate clean WebVTT files with timestamps and speaker labels.
"""

from dataclasses import dataclass
from typing import Optional

from ..core.types import TranscriptionResult, TranscriptSegment


@dataclass
class WebVTTConfig:
    """Simple configuration for WebVTT generation."""
    
    include_speaker_labels: bool = True       # Include speaker identification
    max_line_length: int = 80                 # Reasonable line length
    speaker_label_format: str = "<v {speaker}>"  # Speaker label format


class EnhancedWebVTTFormatter:
    """Simple WebVTT formatter focused on core functionality."""
    
    def __init__(self, config: Optional[WebVTTConfig] = None):
        """Initialize formatter with configuration."""
        self.config = config or WebVTTConfig()
    
    def format(self, result: TranscriptionResult) -> str:
        """Generate WebVTT content from transcription result.
        
        Args:
            result: Transcription result to format
            
        Returns:
            WebVTT content as string
        """
        lines = ['WEBVTT', '']  # WebVTT header
        
        # Add metadata if available
        if result.metadata:
            lines.append('NOTE')
            lines.append(f'Generated by VTTiro using {result.provider}')
            if result.language:
                lines.append(f'Language: {result.language}')
            lines.append('')
        
        # Generate cues from segments
        for i, segment in enumerate(result.segments, 1):
            # Format timestamp
            start_time = self._format_timestamp(segment.start)
            end_time = self._format_timestamp(segment.end)
            
            # Add cue header
            lines.append(f'{i}')
            lines.append(f'{start_time} --> {end_time}')
            
            # Format text with speaker labels if needed
            text = segment.text.strip()
            if self.config.include_speaker_labels and segment.speaker:
                text = f"{self.config.speaker_label_format.format(speaker=segment.speaker)}{text}"
            
            # Break long lines
            text = self._break_long_lines(text)
            lines.append(text)
            lines.append('')  # Empty line between cues
        
        return '\n'.join(lines)
    
    def _format_timestamp(self, seconds: float) -> str:
        """Format seconds as WebVTT timestamp (HH:MM:SS.mmm)."""
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        secs = seconds % 60
        return f"{hours:02d}:{minutes:02d}:{secs:06.3f}"
    
    def _break_long_lines(self, text: str) -> str:
        """Break long lines at reasonable points."""
        if len(text) <= self.config.max_line_length:
            return text
        
        # Simple line breaking at spaces
        words = text.split()
        lines = []
        current_line = []
        current_length = 0
        
        for word in words:
            word_length = len(word) + (1 if current_line else 0)  # +1 for space
            
            if current_length + word_length <= self.config.max_line_length:
                current_line.append(word)
                current_length += word_length
            else:
                if current_line:
                    lines.append(' '.join(current_line))
                    current_line = [word]
                    current_length = len(word)
                else:
                    # Single word longer than max length
                    lines.append(word)
                    current_line = []
                    current_length = 0
        
        if current_line:
            lines.append(' '.join(current_line))
        
        return '\n'.join(lines)
    
    # Legacy compatibility method
    def format_transcription(self, result: TranscriptionResult) -> tuple[str, dict]:
        """Legacy compatibility method that returns simple metrics.
        
        This method exists for backward compatibility but without complex metrics.
        """
        webvtt_content = self.format(result)
        
        # Simple metrics for compatibility
        basic_metrics = {
            'total_cues': len(result.segments),
            'total_duration': max(seg.end for seg in result.segments) if result.segments else 0.0,
            'avg_cue_duration': sum(seg.end - seg.start for seg in result.segments) / len(result.segments) if result.segments else 0.0
        }
        
        return webvtt_content, basic_metrics